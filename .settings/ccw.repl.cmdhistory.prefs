-cmdhistory=[";; Switching to GeneticJVM.core namespace" "(+ 2 3)" "(defn welcome\\r\\n  [x]\\r\\n  (println \\"Welcome To The Clojure Age, \\" x))" "(welcome \\"inbar\\")" "'(welcome \\"inbar\\")" "(welcome 'inbar)" "(welcome inbar)" "(welcome 'inbar)" "'(welcome inbar)" "(rand 1)" "(rand-int 1)" "(rand-int 2)" "\\n[\\"a\\" \\"b\\" \\"c\\"]" "(rand-nth [\\"a\\" \\"b\\" \\"c\\"])" "[\\"a\\" \\"b\\" \\"c\\"]" "\=> (rand-nth [\\"a\\" \\"b\\" \\"c\\"])" "(rand-nth [\\"a\\" \\"b\\" \\"c\\"])" "abc\= (rand-nth [\\"a\\" \\"b\\"])" "(\= abc (rand-nth [\\"a\\" \\"b\\"]))" "(\:abc [\\"a\\" \\"b\\"])" "\:abc" "\:abc\= [\\"a\\" \\"b\\"]" "\:abc" "abc" "{\:abc [\\"a\\" \\"b\\" \\"c\\"]}" "\:abc" "(map a {\:abc [\\"a\\" \\"b\\" \\"c\\"]})" "(keywork abc)" "(keyword abc)" "(def abc {\\"a\\" \\"b\\" \\"c\\"})" "(def a-b-c-Map {\:a \\r\\n                           {\:b \\r\\n                               {\:c 6}\\r\\n                             }\\r\\n                        })" "a-b-c-Map" "\\n(def abc {\:a \\"a\\",\:b \\"b\\",\:c \\"c\\"})" "abc" "(abc \:a)" "(rand-nth abc)" "(def abc [ \:a \\"a\\",\:b \\"b\\",\:c \\"c\\"])" "abc" "(abc \:a)" "(def abc [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\" \\"f\\" \\"g\\" \\"h\\" \\"i\\" \\"j\\" \\"k\\" \\"l\\" \\"m\\" \\"n\\" \\"o\\" \\"p\\" \\"q\\" \\"r\\" \\"s\\" \\"t\\" \\"u\\" \\"v\\" \\"w\\" \\"x\\" \\"y\\" \\"z\\"])" "abc" "\\n(rand-nth abc)" "(rand-nth abc)" "(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)" "(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)(rand-nth abc)" "(range \\"a\\" \\"z\\")" "(for [x [0 1 2 3 4 5]\\n      \:let [y (* x 3)]\\n      \:when (even? y)]\\n  y)" "(def person [])" "person" "(dotimes [n 15] \\n  (def person \\n    (conj person \\n          (rand-nth abc)\\n    )\\n  )\\n)" "PERSON" "person" "(dotimes [n 15] \\r\\n     (def person \\r\\n       (conj person \\r\\n             (rand-nth abc)\\r\\n       )\\r\\n     )\\r\\n   )" "person" "(str person)" "person" "(format pattern person)" "(def pattern \\"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\")" "\=> (format pattern person)" "(format pattern person)" "(str person)" "(dotimes [n PopulationSize]\\r\\n  (\\r\\n\\t\\t(def Person [])\\r\\n\\t\\t(dotimes [n 15] \\r\\n\\t\\t  (def person \\r\\n\\t\\t    (conj person \\r\\n\\t\\t          (rand-nth abc)\\r\\n\\t\\t    )\\r\\n\\t\\t  )\\r\\n\\t\\t)\\r\\n  )\\r\\n)"]
cmdhistory=[";; Switching to GeneticJVM.core namespace" "(ns GeneticJVM.core)\\r\\n\\r\\n;; WE HAVE RANDOM TARGET\!\\r\\n(def PopulationSize 3000)\\r\\n(def GA_MaxIterations 16384) ;the number of generations\\r\\n\\r\\n(defn getPersonChar []  ;rand char\\r\\n  (char (+ (rand-int 90) 32)))\\r\\n\\r\\n;_InitPerson returns a random initial person vector\\r\\n(defn _InitPerson [i]\\r\\n  (cond\\r\\n    (\= i PersonLength) [] \\r\\n    \:else  (vec (cons (getPersonChar ) (_InitPerson (inc i) ))))\\r\\n  )\\r\\n  \\r\\n;calc the fitness of a person,returns map of the person and his fitness\\r\\n(def fitness 0)\\r\\n(defn calc_fitness [person target] \\r\\n(letfn [(fit [fitness p t]\\r\\n         (if (empty? p )\\r\\n           {person fitness}  \\r\\n           (recur (+ fitness (Math/abs (- (int (first p)) (int(first t))))) (rest p) (rest t))))]\\r\\n  (fit 0 person target))\\r\\n  )  \\r\\n\\r\\n;_InitPopulation returns a random intial population vector\\r\\n(defn _InitPopulation [i]\\r\\n ;(println \\"i\: \\" i \\"a\\" (_InitPerson 0 ))\\r\\n  (cond\\r\\n    (\= i PopulationSize) {}\\r\\n    \:else (merge (calc_fitness (_InitPerson 0 ) target) (_InitPopulation (+ i 1))))\\r\\n  )\\r\\n\\r\\n;sort the population map by fitness value in a form of a map\\r\\n(defn sort_by_fitness [population] \\r\\n  (into (sorted-map-by (fn [key1 key2] (compare [(population key1) key1] [(population key2) key2]))) population))\\r\\n\\r\\n;selection of the best persons (10% is the elitism rate)\\r\\n(def elitism_rate 0.1) \\r\\n(def elitism_size (int (* elitism_rate PopulationSize)))\\r\\n(def rest_elitism_size (- PopulationSize elitism_size)) \\r\\n\\r\\n(defn elitism [i population] \\r\\n  ;(println \\"i\: \\" i )\\r\\n  (cond\\r\\n    (\= i elitism_size) {} \\r\\n    \:else (merge (into {} \#{(first population)}) (elitism (inc i) (rest population)))) ;convert from vector to map\\r\\n  )\\r\\n;;call elitism- (sort_by_fitness (elitism 0 Sorted_Initpop))\\r\\n\\r\\n;(defn take-greatest-vals [n m]\\r\\n      ;  (when-let [entries (seq m)]\\r\\n       ;   (reduce (fn [best x]\\r\\n        ;            (if (>\= (val x) (val (last best)))\\r\\n         ;             (vec (take n (conj best x)))\\r\\n          ;            best))\\r\\n           ;      [(first entries)] (rest entries))))\\r\\n\\r\\n;(into {} (take-greatest-vals 10 (sort_by_fitness InitPopulation)))\\r\\n\\r\\n;mutation- change a letter in a person\\r\\n(defn MutationPerson [person]\\r\\n   (def rnum (rand-int PersonLength)) ;(println \\"mutaion\:\\" rnum person)\\r\\n  (assoc person rnum (getPersonChar ) )\\r\\n  )\\r\\n\\r\\n;cross-over between two parents\\r\\n(defn cross-over [parent1 parent2]\\r\\n   (def rnum (rand-int PersonLength))  \\r\\n   ;(println \\"cross-over\\" rnum parent1 parent2)\\r\\n   (vec (flatten (cons (take rnum parent1) (take-last (- PersonLength rnum) parent2))))   \\r\\n   )\\r\\n\\r\\n;Random Parent in form of vector-select a Parent\\r\\n(defn Rand_Parent [population]\\r\\n  (nth (keys population) (rand-int (int (/ PopulationSize 2))))) ;choosing randomic person from the better half of the population for mating\\r\\n\\r\\n(def MutationRate 0.25)\\r\\n(def RandMax 40)\\r\\n(def GA_Mutation (* MutationRate RandMax))\\r\\n\\r\\n;(def restp (take-last (- PopulationSize elitism_size) (sort_by_fitness InitPopulation)))\\r\\n; (def restp (take-last (- PopulationSize elitism_size) population)) ;the rest of population\\r\\n;returns a map of one child and his fitness\\r\\n(defn Mate [parent1 parent2]\\r\\n  (calc_fitness (if (< (rand-int RandMax) GA_Mutation) ((comp MutationPerson cross-over) parent1 parent2)  \\r\\n    (cross-over parent1 parent2)) target) ;getting new infant +mutaion if needed , in a form of key+fitness value\\r\\n  )\\r\\n\\r\\n;create a coll size of rest_elitism_size,returns a vector of Perosns from the better half of the population\\r\\n(defn Selection [population]\\r\\n  (letfn [(select [i person]\\r\\n                  (if (\= i rest_elitism_size) person \\r\\n                    (recur (inc i) (vec(cons (Rand_Parent population) person)))))]\\r\\n  (select 0 (vector (Rand_Parent population))))\\r\\n  )\\r\\n;(Selection Sorted_Initpop) \\r\\n\\r\\n;creates the new population (elitism+ the mate of the rest)\\r\\n(defn Mate2 [population]\\r\\n  (def Elite (elitism 0 population))\\r\\n  (def restMate (into {} (map Mate (Selection population) (Selection population))))\\r\\n  (sort_by_fitness (merge Elite restMate))\\r\\n  )\\r\\n\\r\\n(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation \\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n    (println \\"iiiiiiii\\" i (first population))\\r\\n  (if  (\= (first (vals population)) 0) (first population)  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  ;(print_best[(first population)]\\r\\n  (recur (inc i) (Mate2 population))))\\r\\n  )\\r\\n  )" "(Main)" "(Main \\"lol\\")" "target" "(ns GeneticJVM.core)\\r\\n\\r\\n(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation \\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n    (println \\"iiiiiiii\\" i (first population))\\r\\n  (if  (\= (first (vals population)) 0) (first population)  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  ;(print_best[(first population)]\\r\\n  (recur (inc i) (Mate2 population))))\\r\\n  )\\r\\n  )\\r\\n;; WE HAVE RANDOM TARGET\!\\r\\n(def PopulationSize 3000)\\r\\n(def GA_MaxIterations 16384) ;the number of generations\\r\\n\\r\\n(defn getPersonChar []  ;rand char\\r\\n  (char (+ (rand-int 90) 32)))\\r\\n\\r\\n;_InitPerson returns a random initial person vector\\r\\n(defn _InitPerson [i]\\r\\n  (cond\\r\\n    (\= i PersonLength) [] \\r\\n    \:else  (vec (cons (getPersonChar ) (_InitPerson (inc i) ))))\\r\\n  )\\r\\n  \\r\\n;calc the fitness of a person,returns map of the person and his fitness\\r\\n(def fitness 0)\\r\\n(defn calc_fitness [person target] \\r\\n(letfn [(fit [fitness p t]\\r\\n         (if (empty? p )\\r\\n           {person fitness}  \\r\\n           (recur (+ fitness (Math/abs (- (int (first p)) (int(first t))))) (rest p) (rest t))))]\\r\\n  (fit 0 person target))\\r\\n  )  \\r\\n\\r\\n;_InitPopulation returns a random intial population vector\\r\\n(defn _InitPopulation [i]\\r\\n ;(println \\"i\: \\" i \\"a\\" (_InitPerson 0 ))\\r\\n  (cond\\r\\n    (\= i PopulationSize) {}\\r\\n    \:else (merge (calc_fitness (_InitPerson 0 ) target) (_InitPopulation (+ i 1))))\\r\\n  )\\r\\n\\r\\n;sort the population map by fitness value in a form of a map\\r\\n(defn sort_by_fitness [population] \\r\\n  (into (sorted-map-by (fn [key1 key2] (compare [(population key1) key1] [(population key2) key2]))) population))\\r\\n\\r\\n;selection of the best persons (10% is the elitism rate)\\r\\n(def elitism_rate 0.1) \\r\\n(def elitism_size (int (* elitism_rate PopulationSize)))\\r\\n(def rest_elitism_size (- PopulationSize elitism_size)) \\r\\n\\r\\n(defn elitism [i population] \\r\\n  ;(println \\"i\: \\" i )\\r\\n  (cond\\r\\n    (\= i elitism_size) {} \\r\\n    \:else (merge (into {} \#{(first population)}) (elitism (inc i) (rest population)))) ;convert from vector to map\\r\\n  )\\r\\n;;call elitism- (sort_by_fitness (elitism 0 Sorted_Initpop))\\r\\n\\r\\n;(defn take-greatest-vals [n m]\\r\\n      ;  (when-let [entries (seq m)]\\r\\n       ;   (reduce (fn [best x]\\r\\n        ;            (if (>\= (val x) (val (last best)))\\r\\n         ;             (vec (take n (conj best x)))\\r\\n          ;            best))\\r\\n           ;      [(first entries)] (rest entries))))\\r\\n\\r\\n;(into {} (take-greatest-vals 10 (sort_by_fitness InitPopulation)))\\r\\n\\r\\n;mutation- change a letter in a person\\r\\n(defn MutationPerson [person]\\r\\n   (def rnum (rand-int PersonLength)) ;(println \\"mutaion\:\\" rnum person)\\r\\n  (assoc person rnum (getPersonChar ) )\\r\\n  )\\r\\n\\r\\n;cross-over between two parents\\r\\n(defn cross-over [parent1 parent2]\\r\\n   (def rnum (rand-int PersonLength))  \\r\\n   ;(println \\"cross-over\\" rnum parent1 parent2)\\r\\n   (vec (flatten (cons (take rnum parent1) (take-last (- PersonLength rnum) parent2))))   \\r\\n   )\\r\\n\\r\\n;Random Parent in form of vector-select a Parent\\r\\n(defn Rand_Parent [population]\\r\\n  (nth (keys population) (rand-int (int (/ PopulationSize 2))))) ;choosing randomic person from the better half of the population for mating\\r\\n\\r\\n(def MutationRate 0.25)\\r\\n(def RandMax 40)\\r\\n(def GA_Mutation (* MutationRate RandMax))\\r\\n\\r\\n;(def restp (take-last (- PopulationSize elitism_size) (sort_by_fitness InitPopulation)))\\r\\n; (def restp (take-last (- PopulationSize elitism_size) population)) ;the rest of population\\r\\n;returns a map of one child and his fitness\\r\\n(defn Mate [parent1 parent2]\\r\\n  (calc_fitness (if (< (rand-int RandMax) GA_Mutation) ((comp MutationPerson cross-over) parent1 parent2)  \\r\\n    (cross-over parent1 parent2)) target) ;getting new infant +mutaion if needed , in a form of key+fitness value\\r\\n  )\\r\\n\\r\\n;create a coll size of rest_elitism_size,returns a vector of Perosns from the better half of the population\\r\\n(defn Selection [population]\\r\\n  (letfn [(select [i person]\\r\\n                  (if (\= i rest_elitism_size) person \\r\\n                    (recur (inc i) (vec(cons (Rand_Parent population) person)))))]\\r\\n  (select 0 (vector (Rand_Parent population))))\\r\\n  )\\r\\n;(Selection Sorted_Initpop) \\r\\n\\r\\n;creates the new population (elitism+ the mate of the rest)\\r\\n(defn Mate2 [population]\\r\\n  (def Elite (elitism 0 population))\\r\\n  (def restMate (into {} (map Mate (Selection population) (Selection population))))\\r\\n  (sort_by_fitness (merge Elite restMate))\\r\\n  )" "(main \\"lol\\")" "(Mainain \\"lol\\")" "(Main \\"lol\\")" "(ns GeneticJVM.core)\\r\\n\\r\\n;; WE HAVE RANDOM TARGET\!\\r\\n(def PopulationSize 3000)\\r\\n(def GA_MaxIterations 16384) ;the number of generations\\r\\n\\r\\n(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation \\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n    (println \\"iiiiiiii\\" i (first population))\\r\\n  (if  (\= (first (vals population)) 0) (first population)  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  ;(print_best[(first population)]\\r\\n  (recur (inc i) (Mate2 population))))\\r\\n  )\\r\\n  )\\r\\n\\r\\n(defn getPersonChar []  ;rand char\\r\\n  (char (+ (rand-int 90) 32)))\\r\\n\\r\\n;_InitPerson returns a random initial person vector\\r\\n(defn _InitPerson [i]\\r\\n  (cond\\r\\n    (\= i PersonLength) [] \\r\\n    \:else  (vec (cons (getPersonChar ) (_InitPerson (inc i) ))))\\r\\n  )\\r\\n  \\r\\n;calc the fitness of a person,returns map of the person and his fitness\\r\\n(def fitness 0)\\r\\n(defn calc_fitness [person target] \\r\\n(letfn [(fit [fitness p t]\\r\\n         (if (empty? p )\\r\\n           {person fitness}  \\r\\n           (recur (+ fitness (Math/abs (- (int (first p)) (int(first t))))) (rest p) (rest t))))]\\r\\n  (fit 0 person target))\\r\\n  )  \\r\\n\\r\\n;_InitPopulation returns a random intial population vector\\r\\n(defn _InitPopulation [i]\\r\\n ;(println \\"i\: \\" i \\"a\\" (_InitPerson 0 ))\\r\\n  (cond\\r\\n    (\= i PopulationSize) {}\\r\\n    \:else (merge (calc_fitness (_InitPerson 0 ) target) (_InitPopulation (+ i 1))))\\r\\n  )\\r\\n\\r\\n;sort the population map by fitness value in a form of a map\\r\\n(defn sort_by_fitness [population] \\r\\n  (into (sorted-map-by (fn [key1 key2] (compare [(population key1) key1] [(population key2) key2]))) population))\\r\\n\\r\\n;selection of the best persons (10% is the elitism rate)\\r\\n(def elitism_rate 0.1) \\r\\n(def elitism_size (int (* elitism_rate PopulationSize)))\\r\\n(def rest_elitism_size (- PopulationSize elitism_size)) \\r\\n\\r\\n(defn elitism [i population] \\r\\n  ;(println \\"i\: \\" i )\\r\\n  (cond\\r\\n    (\= i elitism_size) {} \\r\\n    \:else (merge (into {} \#{(first population)}) (elitism (inc i) (rest population)))) ;convert from vector to map\\r\\n  )\\r\\n;;call elitism- (sort_by_fitness (elitism 0 Sorted_Initpop))\\r\\n\\r\\n;(defn take-greatest-vals [n m]\\r\\n      ;  (when-let [entries (seq m)]\\r\\n       ;   (reduce (fn [best x]\\r\\n        ;            (if (>\= (val x) (val (last best)))\\r\\n         ;             (vec (take n (conj best x)))\\r\\n          ;            best))\\r\\n           ;      [(first entries)] (rest entries))))\\r\\n\\r\\n;(into {} (take-greatest-vals 10 (sort_by_fitness InitPopulation)))\\r\\n\\r\\n;mutation- change a letter in a person\\r\\n(defn MutationPerson [person]\\r\\n   (def rnum (rand-int PersonLength)) ;(println \\"mutaion\:\\" rnum person)\\r\\n  (assoc person rnum (getPersonChar ) )\\r\\n  )\\r\\n\\r\\n;cross-over between two parents\\r\\n(defn cross-over [parent1 parent2]\\r\\n   (def rnum (rand-int PersonLength))  \\r\\n   ;(println \\"cross-over\\" rnum parent1 parent2)\\r\\n   (vec (flatten (cons (take rnum parent1) (take-last (- PersonLength rnum) parent2))))   \\r\\n   )\\r\\n\\r\\n;Random Parent in form of vector-select a Parent\\r\\n(defn Rand_Parent [population]\\r\\n  (nth (keys population) (rand-int (int (/ PopulationSize 2))))) ;choosing randomic person from the better half of the population for mating\\r\\n\\r\\n(def MutationRate 0.25)\\r\\n(def RandMax 40)\\r\\n(def GA_Mutation (* MutationRate RandMax))\\r\\n\\r\\n;(def restp (take-last (- PopulationSize elitism_size) (sort_by_fitness InitPopulation)))\\r\\n; (def restp (take-last (- PopulationSize elitism_size) population)) ;the rest of population\\r\\n;returns a map of one child and his fitness\\r\\n(defn Mate [parent1 parent2]\\r\\n  (calc_fitness (if (< (rand-int RandMax) GA_Mutation) ((comp MutationPerson cross-over) parent1 parent2)  \\r\\n    (cross-over parent1 parent2)) target) ;getting new infant +mutaion if needed , in a form of key+fitness value\\r\\n  )\\r\\n\\r\\n;create a coll size of rest_elitism_size,returns a vector of Perosns from the better half of the population\\r\\n(defn Selection [population]\\r\\n  (letfn [(select [i person]\\r\\n                  (if (\= i rest_elitism_size) person \\r\\n                    (recur (inc i) (vec(cons (Rand_Parent population) person)))))]\\r\\n  (select 0 (vector (Rand_Parent population))))\\r\\n  )\\r\\n;(Selection Sorted_Initpop) \\r\\n\\r\\n;creates the new population (elitism+ the mate of the rest)\\r\\n(defn Mate2 [population]\\r\\n  (def Elite (elitism 0 population))\\r\\n  (def restMate (into {} (map Mate (Selection population) (Selection population))))\\r\\n  (sort_by_fitness (merge Elite restMate))\\r\\n  )" "(Main \\"INbAR4\\")" ";; Switching to GeneticJVM.core namespace" "(Main \\"I Love Clojure\!\\")" "(deftest my-test\\r\\n  (Main \\"I Love Clojure\!\\")  )" "(deftest a-test\\r\\n  (testing \\"FIXME, I fail.\\"\\r\\n    (is (\= 0 1))))" ";; Switching to GeneticJVM.core-test namespace" "(a-test)" "(my-test)" ";; Switching to GeneticJVM.core namespace" "(Main \\"my FIrsT5 val is \!?\\")" "(Main \\"I have LLLLonggg string..and I like it\!\\")" ";; Switching to GeneticJVM.core-test namespace" ";; Switching to GeneticJVM.core namespace" "(Main \\"I-I like it\!\\")" "(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (println \\"Creating Initial Population\\")\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation -not sure if need\\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n  (println \\"Iteration\\" i \\"best\: \\" (first population))   ;(print_best[(first population)]\\r\\n  (if  (\= (first (vals population)) 0) (println (first (keys population)))  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  (recur (inc i) (Mate2 population)))))\\r\\n  )" "(Main \\"I like it\!\\")" "(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (println \\"Creating Initial Population\\")\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation -not sure if need\\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n  (println \\"Iteration\\" i \\"best\: \\" (first population))   ;(print_best[(first population)]\\r\\n  (if  (\= (first (vals population)) 0) (println \\"we got it\!\\" (first (keys population)))  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  (recur (inc i) (Mate2 population)))) (println \\"Iteration\\" i))\\r\\n  )" "(ns GeneticJVM.core)\\r\\n\\r\\n;; WE HAVE RANDOM TARGET\!\\r\\n(def target) ;because the functions use this definition, we define it in Main\\r\\n(def PersonLength) ;target length ;because the functions use this definition, we define it in Main\\r\\n(def PopulationSize 3000)\\r\\n(def GA_MaxIterations 16384) ;the number of generations\\r\\n\\r\\n(defn getPersonChar []  ;rand char between \\\\space to \\\\z\\r\\n  (char (+ (rand-int 90) 32)))\\r\\n\\r\\n;_InitPerson returns a random initial person vector\\r\\n(defn _InitPerson [i]\\r\\n  (cond\\r\\n    (\= i PersonLength) [] \\r\\n    \:else  (vec (cons (getPersonChar ) (_InitPerson (inc i) ))))\\r\\n  )\\r\\n  \\r\\n;calc the fitness of a person,returns map of the person and his fitness\\r\\n(def fitness 0)\\r\\n(defn calc_fitness [person target] \\r\\n(letfn [(fit [fitness p t]\\r\\n         (if (empty? p )\\r\\n           {person fitness}  \\r\\n           (recur (+ fitness (Math/abs (- (int (first p)) (int(first t))))) (rest p) (rest t))))]\\r\\n  (fit 0 person target))\\r\\n  )  \\r\\n\\r\\n;_InitPopulation returns a random intial population vector\\r\\n(defn _InitPopulation [i]\\r\\n  (cond\\r\\n    (\= i PopulationSize) {}\\r\\n    \:else (merge (calc_fitness (_InitPerson 0 ) target) (_InitPopulation (+ i 1))))\\r\\n  )\\r\\n\\r\\n;sort the population map by fitness value in a form of a map\\r\\n(defn sort_by_fitness [population] \\r\\n  (into (sorted-map-by (fn [key1 key2] (compare [(population key1) key1] [(population key2) key2]))) population))\\r\\n\\r\\n;selection of the best persons (10% is the elitism rate)\\r\\n(def elitism_rate 0.1) \\r\\n(def elitism_size (int (* elitism_rate PopulationSize)))\\r\\n(def rest_elitism_size (- PopulationSize elitism_size)) \\r\\n\\r\\n(defn elitism [i population] \\r\\n  (cond\\r\\n    (\= i elitism_size) {} \\r\\n    \:else (merge (into {} \#{(first population)}) (elitism (inc i) (rest population)))) ;convert from vector to map\\r\\n  )\\r\\n\\r\\n;mutation- change a letter in a person\\r\\n(defn MutationPerson [person]\\r\\n   (def rnum (rand-int PersonLength)) ;(println \\"mutaion\:\\" rnum person)\\r\\n  (assoc person rnum (getPersonChar ) )\\r\\n  )\\r\\n\\r\\n;cross-over between two parents\\r\\n(defn cross-over [parent1 parent2]\\r\\n   (def rnum (rand-int PersonLength))  \\r\\n   (vec (flatten (cons (take rnum parent1) (take-last (- PersonLength rnum) parent2))))   \\r\\n   )\\r\\n\\r\\n;Random Parent in form of vector-select a Parent\\r\\n(defn Rand_Parent [population]\\r\\n  (nth (keys population) (rand-int (int (/ PopulationSize 2))))) ;choosing randomic person from the better half of the population for mating\\r\\n\\r\\n(def MutationRate 0.25)\\r\\n(def RandMax 40)\\r\\n(def GA_Mutation (* MutationRate RandMax))\\r\\n\\r\\n;returns a map of one child and his fitness\\r\\n(defn Mate [parent1 parent2]\\r\\n  (calc_fitness (if (< (rand-int RandMax) GA_Mutation) ((comp MutationPerson cross-over) parent1 parent2)  \\r\\n    (cross-over parent1 parent2)) target) ;getting new infant +mutaion if needed , in a form of key+fitness value\\r\\n  )\\r\\n\\r\\n;create a coll size of rest_elitism_size,returns a vector of Perosns from the better half of the population\\r\\n(defn Selection [population]\\r\\n  (letfn [(select [i person]\\r\\n                  (if (\= i rest_elitism_size) person \\r\\n                    (recur (inc i) (vec(cons (Rand_Parent population) person)))))]\\r\\n  (select 0 (vector (Rand_Parent population))))\\r\\n  ) \\r\\n\\r\\n;creates the new population (elitism+ the mate of the rest)\\r\\n(defn Mate2 [population]\\r\\n  (def Elite (elitism 0 population))\\r\\n  (def restMate (into {} (map Mate (Selection population) (Selection population))))\\r\\n  (sort_by_fitness (merge Elite restMate))\\r\\n  )\\r\\n\\r\\n(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (println \\"Creating Initial Population\\")\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation -not sure if need\\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n  (println \\"Iteration\\" i \\"best\: \\" (first population))   ;(print_best[(first population)]\\r\\n  (if  (\= (first (vals population)) 0) (println \\"we got it\!\\" (first (keys population)))  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  (recur (inc i) (Mate2 population)))))\\r\\n  )" "(Main \\"I like it\!\\")" "(defn Main [input]\\r\\n  (def target input)\\r\\n  (def PersonLength (count target))\\r\\n  (println \\"Creating Initial Population\\")\\r\\n  (def InitPopulation (_InitPopulation 0))\\r\\n  (def Sorted_Initpop (sort_by_fitness InitPopulation))\\r\\n  ;print new population as strings   NewPopulation -not sure if need\\r\\n  (loop [i 0 population Sorted_Initpop] \\r\\n  (println \\"Iteration\\" i \\"best\: \\" (first population))   ;(print_best[(first population)]\\r\\n  (if  (\= (first (vals population)) 0) (println \\"we got it\!   \\" (first (keys population)))  ;print \\"i love clojure\!\\"\\r\\n  (if  (\= i GA_MaxIterations) (println \\"sorry..\\") ;didnt get our target\\r\\n  (recur (inc i) (Mate2 population)))))\\r\\n  )" "(Main \\"I it\!\\")"]
eclipse.preferences.version=1
